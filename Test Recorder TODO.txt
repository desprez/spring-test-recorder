
INFO ==========================
	There is another test recorder 
		http://testrecorder.amygdalum.net/index.html
		Get from github and try to see what tests are generated
		
	How to use proxy and dynamic-pointcut
		http://www.java2s.com/Code/Java/Spring/DynamicPointcutExample.htm
		http://stonefishy.github.io/blog/2015/06/12/spring-aop-dynamic-pointcut/
		Can I create proxy for the target service (if it's service) and use proxies for all the target dependencies?
		
		
		
	How to write custom annotations - in case I need
		What if the objects do not have public fields or getters?
		I need just a visitor inserted in all args and all dependencies of args
			will return objectState + name of params for all methods and constructors
		Easy solution - adnotate each class that I want to get the state with an Annotation
	
		We could do like Lombok does and inject some method to give us info about the dependencies
		http://notatube.blogspot.com/2010/12/project-lombok-creating-custom.html
		https://blog.frankel.ch/lombok-reduces-your-boilerplate-code/
		https://www.baeldung.com/java-annotation-processing-builder
		https://blog.frankel.ch/introductory-guide-annotation-processor/
			you can use a maven plugin to run such annotations
		Good Example of generating a class from annotations
			https://iammert.medium.com/annotation-processing-dont-repeat-yourself-generate-your-code-8425e60c6657
		Instrumentation example
			This is how mockito 2 can extend final classes
			https://www.developer.com/design/what-is-java-agent/
		See the sources of Lombok	
			https://github.com/projectlombok/lombok
		
		https://softwareengineering.stackexchange.com/questions/147055/when-is-unit-testing-inappropriate-or-unnecessary
		JUnit FAQ
			http://junit.sourceforge.net/doc/faq/faq.htm#best_1
		Types of functional tests
			https://www.simform.com/functional-testing-types/

	How to use spring-test-recorder
		<dependency>
			<groupId>com.onushi</groupId>
			<artifactId>spring-test-recorder</artifactId>
			<version>0.1.0</version>
		</dependency>
		
		Maven refresh
		
		@ComponentScan(basePackages={..., "com.onushi.springtestrecorder"},

		import com.onushi.springtestrecorder.aspect.RecordTest;
		
		add @RecordTest to the function you want to record



DONE ==========================
	OK - Handle also exceptions thrown by act
		assertThrows(IllegalArgumentException.class, () -> new SampleService().testException(5));
	OK - if it's @Component or not

	OK - if the class has equals or not

	OK - handle arrays
	
	OK - handle ArrayList<>

	OK - the dependencies (also dependencies of dependencies ...)
		keep all dependencies in the test to avoid creation of 2 ObjectInfo for the same object
	OK - different objects can have common dependencies
		we need a dependency sorter
	OK - why args types are generated as 
			List<Person> arrayList1 and 
		but results as
			List result?
	OK - problem with repeated args

	OK - cache objects per TestGenerator

	OK - Get fields to set from getters and public fields to Optional<>
	
	OK Get constructors and their arguments
	
	OK - a object with an int == 0 will be initialized with NoArgs

	OK - see what happens when the fields are from superclass

	-----

	OK - Object creation for the target object

	OK - if there is a identifiable constructor covering all the fields
			Create with args constructor 

	OK - if there is a NoArg constructor + public fields
		Create with fields 
		
	-----
	
	OK - Refactor factory

	OK - // TODO create this object
		 // Person person = new Person();
		 // person.firstName = "firstName";
		 // person.lastName = "lastName"
		 // person.age = 35;
		 
	------
	
	OK - Create a function that will return the possible name of the setters
		Or that will find the setter Methods for a field name

	OK - if there is a NoArg constructor + all setters
		Create with setters 
		
	OK - Add objectState to context
	
	---------

	OK - The application being tested should not crash because of RecordTest

	OK - Problems with the CGLIB proxyes
		When a component is injected in a component a proxy is generated

	RecordMockForTest
		OK - create the type annotation and itercept all public calls inside the type
		
		OK - Intercept all calls inside methods with RecordMockForTest
			add them to RecordedMethodRunInfo.dependencyMethodRuns

	OK - check that both aspects run on the same thread

	OK - will match RecordedMethodRunInfo only with DependencyMethodRunInfo from the same thread
		store current thread
			int threadId = Thread.currentThread().getId()
			
	OK - RecordMockForTestAspect works only on injected components

	OK - implement first mocking

	OK - try with 2 mocked calls

	OK - try mock with 2 arguments

	OK - try when the mock argument is null
	
	OK - why is the import moving around between test runs?

	OK - handle exception thrown from the mocked function

	OK - exception thrown by mock for void returning functions

	OK - I should include doThrow

	OK - why NoSuchElementException cannot be created by the generic code?
		What should I do for such cases?
		We don't have to cover all cases for now. If an object cannot be created automatically, the user has to create it

	------
		OK - Enum
		OK - UUID
		OK - Fix getVariableName
		OK - Fix ObjectInfo constructor

	------
		OK - HashMap<>
	------
		OK - Set<>
		Solve !!!!
		
	------
		OK - escape strings
		OK - TODO rename the test to describe the use case
		OK - TODO refactor the generated code to make it easier to understand
		
		OK - Add generation date and tool
			but how can I ignore it in tests?
			Test Generated on ... with @RecordTest
		
	------
	OK - Write a demo to understand how the equality should behave
	
	OK - I need to do something about the expected result
		Should be treated as a normal object in the TextGenerator context

	OK - if exception was thrown
		no expectedResult init
		no check

	OK - object is void
		no expectedResult init
		no check

	OK - object is null
		no expectedResult init
		simple assertNull
		
	OK - primitive
		no expectedResult init
		simple assertEquals
		
	OK - result == one of the known objects
		assertEquals(object, result)

	OK - object has equals
		expectedResult init if it's not in the Context already
		simple assertEquals
		
	OK object has public (protected) getters / public (protected) fields
		create an ObjectReadAnalyzerService()
			return all getters 
			return all public fields
			don't care about the objectState
			don't care about calculating the name of getters for fields	

	------
		OK - assertTrue
		
		OK - assertNull
		
		OK - implement assert and test for HashMap, HashSet
		
		OK - Implement dependencies for asserts
		
		OK - fix all warnings

		OK - What happens when the target method returns an interface?

		OK - Split TestGeneratorService to subservices

	------
		OK - create CodeTree classes + test
		
		OK - move attributes from TestGeneratorService to subservices
		
		OK - split asserts to be more readable
		
		OK - split ObjectsInit to be more readable
	
	------
		OK - Create a demo with complex args objects, mock and object asserts
	
	10.06.2021 =========
		OK - Order in TestGeneratorServiceTests

	11.06.2021 =========
		OK - Clean my github account 
		
		OK - Rename project in gitHub to TestRecorder
		
		OK - Rename to TestRecorder
		
		OK - Transform TestRecorder to library
		
		OK - publish library in local repository with mvc clean install
		
		OK - add TestRecorder dependency from local repository in a target project
		
		OK - manage to generate the first code in another project by importing TestGenerator package from local maven repository

		OK - Test for a class with no constructor
			do I consider that it has a public NoArgs constructor?
	
	12.06.2021 =========
		OK - Manage to run the TestRecorder together with the target project
		
		OK - Allow object creation with NoArgsAndFields when same package and fields are package or protected
		
		OK - assertFalse

		OK - when same package allow use of package or protected constructors / setters 
			OK - ObjectInfoFactoryWithNoArgsAndFieldsImpl

			OK - ObjectInfoFactoryWithLombokBuilderImpl

			OK - ObjectInfoFactoryWithNoArgsConstructorImpl

			OK - ObjectInfoFactoryWithNoArgsAndSettersImpl

			OK - ObjectInfoFactoryWithAllArgsConstructorImpl
		
	17.06.2021 =========
		OK - Why mocking does not work anymore?
			maybe because I change the order of some init in TestGeneratorFactory
			
	
		OK - Create spring-test-recorder-demo

		OK - rename projects on disk, sources and github
			spring-test-recorder
			spring-test-recorder-demo
			
		OK - rename main branch to master
		
		OK - Split RecordedMethodRunInfo in 2
			BeforeMethodRunInfo
			AfterMethodRunInfo
			Unshelf "implement the new way of creating TestGenerator in the 2 aspects"
			
		OK - 	Bug. If I modify the params, the test will have them already modified
			It's ok to construct init objects from current value since 
				before objects are used in arange
				after objects are used after
				if there are some common ones, they are inited before so it's ok
				keep a bool about when an object is inited
				also when an object cannot be created, create it's dependencies and add a TODO that the object should be created 
		
			Refactor plan
				RecordedMethodRunInfo should be split in 2 
					BeforeMethodRunInfo
					AfterMethodRunInfo
					
			TestGenerator and TestGeneratorFactory should use these 2 objects
					
			for the args + target
				construct ObjectInfos
				
			call the target.method()
			
			For all existing objects 
				get objects for result + dependencies

		OK - Add complex demo in a separate project
			private void demo() throws Exception {
				List<Integer> personIds = new ArrayList<>();
				personIds.add(1);
				personIds.add(2);

				Map<Integer, Person> personMap = this.personService.loadPersons(personIds);
			}

		OK - In TestGenerator keep track of TestRecordingPhase
		
	2021.18.06 =============
		SIDE EFFECTS
			OK - Write a demo to understand the problem


			OK - VisiblePropertySnapshot
				PropertyValue propertyValue
				List<ObjectInfo> dependencies
			
			OK - VisibleProperty should contain a 
				Map<TestRecordingPhase, VisiblePropertySnapshot> snapshots
				
			OK - create a function in ObjectInfoFactory to save snapshots
			
			OK - all the things saved now in finalValue and finalDependencies should be put in snapshots
			
			OK - use the snapshots for assert
			
			OK - one by one all the calls to addVisibleProperty should be converted to saveSnapshot
			
			OK - remove finalValue and finalDependencies
	
			OK - save values in the correct TestRecordingPhase
	

TODO ==========================

	SIDE EFFECTS
		save values before and after
		
		create asserts when value change between snapshots

		Write tests for different cases of objects reuse, side effects etc

		Check side effects on target, arguments, any dependencies

		VisibleProps should be computed for every object before and after the call 
			fill initialValue for all objects in the context

			fill finalValue for all objects in the context

		How can I know if an object was changed from side effects? 
			add equals to StringOrObjectInfo
			if no initial
				=> not changed
			else 
				Compare visibleProperties



	I should create objects as soon as possible
		this applies to mocked params and returns


	If I am unable to create an object, I should still create it's dependencies and a commented code that sets it's private props

	for iterations, generate asserts for max 3 items and add a comment about the parameter
		in visibleProperties keep all
	
	DZone - article about spring-test-recorder
	
	Does it work in Spring projects without SpringBoot?
	
	Does it work in normal projects?
		AspectJ should be called somehow
	
	Publish a library to MAVEN Repository
		https://dzone.com/articles/how-to-create-a-java-library-from-scratch-to-maven
	
	Exceptions thrown are not added to includes
		in mocks
		in test

	Is there a problem with boxed vs unboxed types?
		Ex: Float / float

	Test what happens when you call a void returning method and want to mock it?

	Handle more classes
		Class class 
		Calendar class
		All List<> from java.utils
		All Set<> from java.utils
		All HashMap<> from java.utils

	sometimes I can use protected setters/properties/getters in assert if the namespace is correct
	
	solve more TODOs
		
	Sometimes variable names are phased: list1, list4, list5
		I could assign names to objects only when adding them to the generated code

	Maybe I should use both Annotations be for Class/Function?
		
	I should generate the code on disk. 
		If not possible, write to console
		Add a parameter to specify the path for generation

	Read again exception handling best practices
		checking params 
		raising exceptions
		where to treat exceptions

	I should add logging for debugging as a param of the Annotation
	
	Demo for IonutP, Rares
	 
	Test in a real project
		See what problems appear

	Write tests for all the code that could break
		check coverage again

	Read when the russian guy said about Git preparation
	
LATER ==========================
	There is a problem with false getters. A getter should start with get or is and be followed be upper letter. There should be a corresponding field
	
	Sometimes we should get child objects separately before assert. Like Department department1 = result.getDepartment(). This works well in ObjectInfo
	
	I could give significant var names from names of fields and getters
	
	For read objects I could limit the depth to 3-4 to avoid stack overflow. Later param + comment
	
	Use visibleProperties as fallback for init, in comment

	Add the date in the in name of the test function to be able to run them in order
		make it a parameter

	I could have a fallback with serializable

	if you have a Component with multiple instances called from the RecordTest method, mocks will be duplicated
	
	allow recording mocks from different threads

    What do I do when some fields could not be read? Do the same for all generic factories
		1. I could ignore them and consider just the rest of fields
		2. I could go to fallback
		
	Consider field default values for all the generic factories
		Do I need to do something? Think for each of them

	Handle other Java common classes

	full injection for factories?
	
	if needed object initialisation code could be learned from github	
	
	Handle Generics

	arrays of arrays
	
	global variables changed - but this is not ok
	
	static fields are not handled yet
	
	
	
