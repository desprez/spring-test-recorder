
INFO ==========================

	There is another test recorder 
		http://testrecorder.amygdalum.net/index.html
		Get from github and try to see what tests are generated
		
	How to use proxy and dynamic-pointcut
		http://www.java2s.com/Code/Java/Spring/DynamicPointcutExample.htm
		http://stonefishy.github.io/blog/2015/06/12/spring-aop-dynamic-pointcut/
		Can I create proxy for the target service (if it's service) and use proxies for all the target dependencies?
		
		
		
	How to write custom annotations - in case I need
		What if the objects do not have public fields or getters?
		I need just a visitor inserted in all args and all dependencies of args
			will return objectState + name of params for all methods and constructors
		Easy solution - annotate each class that I want to get the state with an Annotation
	
		We could do like Lombok does and inject some method to give us info about the dependencies
		http://notatube.blogspot.com/2010/12/project-lombok-creating-custom.html
		https://blog.frankel.ch/lombok-reduces-your-boilerplate-code/
		https://www.baeldung.com/java-annotation-processing-builder
		https://blog.frankel.ch/introductory-guide-annotation-processor/
			you can use a maven plugin to run such annotations
		Good Example of generating a class from annotations
			https://iammert.medium.com/annotation-processing-dont-repeat-yourself-generate-your-code-8425e60c6657
		Instrumentation example
			This is how mockito 2 can extend final classes
			https://www.developer.com/design/what-is-java-agent/
		See the sources of Lombok	
			https://github.com/projectlombok/lombok
		
		https://softwareengineering.stackexchange.com/questions/147055/when-is-unit-testing-inappropriate-or-unnecessary
		JUnit FAQ
			http://junit.sourceforge.net/doc/faq/faq.htm#best_1
		Types of functional tests
			https://www.simform.com/functional-testing-types/

	How to use spring-test-recorder
		<dependency>
			<groupId>org.springtestrecorder</groupId>
			<artifactId>spring-test-recorder</artifactId>
			<version>0.2.0</version>
		</dependency>
		
		Maven refresh
		
		@ComponentScan(basePackages={"...", "org.springtestrecorder"})

		import RecordTest;
		
		add @RecordTest to the function you want to record



DONE ==========================
	OK - Handle also exceptions thrown by act
		assertThrows(IllegalArgumentException.class, () -> new SampleService().testException(5));
	OK - if it's @Component or not

	OK - if the class has equals or not

	OK - handle arrays
	
	OK - handle ArrayList<>

	OK - the dependencies (also dependencies of dependencies ...)
		keep all dependencies in the test to avoid creation of 2 ObjectInfo for the same object
	OK - different objects can have common dependencies
		we need a dependency sorter
	OK - why args types are generated as 
			List<Person> arrayList1 and 
		but results as
			List result?
	OK - problem with repeated args

	OK - cache objects per TestGenerator

	OK - Get fields to set from getters and public fields to Optional<>
	
	OK Get constructors and their arguments
	
	OK - a object with an int == 0 will be initialized with NoArgs

	OK - see what happens when the fields are from superclass

	-----

	OK - Object creation for the target object

	OK - if there is a identifiable constructor covering all the fields
			Create with args constructor 

	OK - if there is a NoArg constructor + public fields
		Create with fields 
		
	-----
	
	OK - Refactor factory

	OK - // TODO create this object
		 // Person person = new Person();
		 // person.firstName = "firstName";
		 // person.lastName = "lastName"
		 // person.age = 35;
		 
	------
	
	OK - Create a function that will return the possible name of the setters
		Or that will find the setter Methods for a field name

	OK - if there is a NoArg constructor + all setters
		Create with setters 
		
	OK - Add objectState to context
	
	---------

	OK - The application being tested should not crash because of RecordTest

	OK - Problems with the CGLIB proxies
		When a component is injected in a component a proxy is generated

	RecordMockForTest
		OK - create the type annotation and intercept all public calls inside the type
		
		OK - Intercept all calls inside methods with RecordMockForTest
			add them to RecordedMethodRunInfo.dependencyMethodRuns

	OK - check that both aspects run on the same thread

	OK - will match RecordedMethodRunInfo only with DependencyMethodRunInfo from the same thread
		store current thread
			int threadId = Thread.currentThread().getId()
			
	OK - RecordMockForTestAspect works only on injected components

	OK - implement first mocking

	OK - try with 2 mocked calls

	OK - try mock with 2 arguments

	OK - try when the mock argument is null
	
	OK - why is the import moving around between test runs?

	OK - handle exception thrown from the mocked function

	OK - exception thrown by mock for void returning functions

	OK - I should include doThrow

	OK - why NoSuchElementException cannot be created by the generic code?
		What should I do for such cases?
		We don't have to cover all cases for now. If an object cannot be created automatically, the user has to create it

	------
		OK - Enum
		OK - UUID
		OK - Fix getVariableName
		OK - Fix ObjectInfo constructor

	------
		OK - HashMap<>
	------
		OK - Set<>
		Solve !!!!
		
	------
		OK - escape strings
		OK - TODO rename the test to describe the use case
		OK - TODO refactor the generated code to make it easier to understand
		
		OK - Add generation date and tool
			but how can I ignore it in tests?
			Test Generated on ... with @RecordTest
		
	------
	OK - Write a demo to understand how the equality should behave
	
	OK - I need to do something about the expected result
		Should be treated as a normal object in the TextGenerator context

	OK - if exception was thrown
		no expectedResult init
		no check

	OK - object is void
		no expectedResult init
		no check

	OK - object is null
		no expectedResult init
		simple assertNull
		
	OK - primitive
		no expectedResult init
		simple assertEquals
		
	OK - result == one of the known objects
		assertEquals(object, result)

	OK - object has equals
		expectedResult init if it's not in the Context already
		simple assertEquals
		
	OK object has public (protected) getters / public (protected) fields
		create an ObjectReadAnalyzerService()
			return all getters 
			return all public fields
			don't care about the objectState
			don't care about calculating the name of getters for fields	

	------
		OK - assertTrue
		
		OK - assertNull
		
		OK - implement assert and test for HashMap, HashSet
		
		OK - Implement dependencies for asserts
		
		OK - fix all warnings

		OK - What happens when the target method returns an interface?

		OK - Split TestGeneratorService to subservices

	------
		OK - create CodeTree classes + test
		
		OK - move attributes from TestGeneratorService to subservices
		
		OK - split asserts to be more readable
		
		OK - split ObjectsInit to be more readable
	
	------
		OK - Create a demo with complex args objects, mock and object asserts
	
	10.06.2021 =============
		OK - Order in TestGeneratorServiceTests

	11.06.2021 =============
		OK - Clean my github account 
		
		OK - Rename project in gitHub to TestRecorder
		
		OK - Rename to TestRecorder
		
		OK - Transform TestRecorder to library
		
		OK - publish library in local repository with mvc clean install
		
		OK - add TestRecorder dependency from local repository in a target project
		
		OK - manage to generate the first code in another project by importing TestGenerator package from local maven repository

		OK - Test for a class with no constructor
			do I consider that it has a public NoArgs constructor?
	
	12.06.2021 =============
		OK - Manage to run the TestRecorder together with the target project
		
		OK - Allow object creation with NoArgsAndFields when same package and fields are package or protected
		
		OK - assertFalse

		OK - when same package allow use of package or protected constructors / setters 
			OK - ObjectInfoFactoryWithNoArgsAndFieldsImpl

			OK - ObjectInfoFactoryWithLombokBuilderImpl

			OK - ObjectInfoFactoryWithNoArgsConstructorImpl

			OK - ObjectInfoFactoryWithNoArgsAndSettersImpl

			OK - ObjectInfoFactoryWithAllArgsConstructorImpl
		
	17.06.2021 =============
		OK - Why mocking does not work anymore?
			maybe because I change the order of some init in TestGeneratorFactory
			
	
		OK - Create spring-test-recorder-demo

		OK - rename projects on disk, sources and github
			spring-test-recorder
			spring-test-recorder-demo
			
		OK - rename main branch to master
		
		OK - Split RecordedMethodRunInfo in 2
			BeforeMethodRunInfo
			AfterMethodRunInfo
			Unshelve "implement the new way of creating TestGenerator in the 2 aspects"
			
		OK - 	Bug. If I modify the params, the test will have them already modified
			It's ok to construct init objects from current value since 
				before objects are used in arrange
				after objects are used after
				if there are some common ones, they are initialised before so it's ok
				keep a bool about when an object is initialised
				also when an object cannot be created, create it's dependencies and add a TODO that the object should be created 
		
			Refactor plan
				RecordedMethodRunInfo should be split in 2 
					BeforeMethodRunInfo
					AfterMethodRunInfo
					
			TestGenerator and TestGeneratorFactory should use these 2 objects
					
			for the args + target
				construct ObjectInfos
				
			call the target.method()
			
			For all existing objects 
				get objects for result + dependencies

		OK - Add complex demo in a separate project
			private void demo() throws Exception {
				List<Integer> personIds = new ArrayList<>();
				personIds.add(1);
				personIds.add(2);

				Map<Integer, Person> personMap = this.personService.loadPersons(personIds);
			}

		OK - In TestGenerator keep track of TestRecordingPhase
		
	2021.06.18 =============
		SIDE EFFECTS
			OK - Write a demo to understand the problem


			OK - VisiblePropertySnapshot
				PropertyValue propertyValue
				List<ObjectInfo> dependencies
			
			OK - VisibleProperty should contain a 
				Map<TestRecordingPhase, VisiblePropertySnapshot> snapshots
				
			OK - create a function in ObjectInfoFactory to save snapshots
			
			OK - all the things saved now in finalValue and finalDependencies should be put in snapshots
			
			OK - use the snapshots for assert
			
			OK - one by one all the calls to addVisibleProperty should be converted to saveSnapshot
			
			OK - remove finalValue and finalDependencies
	
			OK - save values in the correct TestRecordingPhase
	
	2021-06-20 =============
		OK - for ArrayList
			OK - save VisiblePropertySnapshots before and after
			
			OK - write test with expected side effects
			
			OK - How can I know if an object was changed from side effects? 
				implement PropertyValue.isSameValue

			OK - getAssertCode is 90% similar
				actually should be the same function since result has only AfterMethodRunInfo so it should appear in asserts
			
			OK - implement and make the test run
		
		SIDE EFFECTS
			OK - Null
			
			OK - ObjectInfoFactoryForArrayListImpl

			OK - ObjectInfoFactoryForDateImpl

			OK - ObjectInfoFactoryForUUIDImpl
				are immutable

			OK - ObjectInfoFactoryForArrayImpl
			
			OK - ObjectInfoFactoryForHashMapImpl
			
			OK - ObjectInfoFactoryForHashSetImpl
			
			OK - setVisiblePropertiesForUnknown

		OK - add all generated tests near generation code

		OK - fix warnings
		
	2021-06-21 =============
		OK - Detect deep changes in objects
		
		OK - Write tests for this

	2021-06-22 =============
		OK - clean side effects related TODOs
		
		OK - mark objects already processed when detecting side effects
		
		OK - activate all tests, again
		
		OK - test side effects on primitives and enums
			there cannot be side effects
		
		OK - SIDE EFFECTS
			Write tests for different cases of objects reuse, side effects etc
			
				OK - Send targetObject as a parameter to targetObject + sideEffects
				
				OK - Return targetObject as a result + sideEffects
				
				OK - Send targetObject as a parameter to targetObject twice and return it + sideEffects		

	2021-06-25 =============
		OK - Learn from Myth of Genius Programmer https://www.youtube.com/watch?v=0SARbwvhupQ
			Don't try to be a genius. There is no genius. Lose the ego
		
			Criticism is not evil
			
			Embrace failure
		
			Fail fast and learn
			
			Dont't try to hide your tracks to protect your ego
			
			Give up the individual ego and get a project ego
			
			In time the failures will get smaller and the successes bigger
			
			Being the biggest fish in the pond will be confortable/safe but you will not learn much
				I say, but becoming the biggest fish moght involve learning a lot ... see 12co
			
			Being willing to admit mistakes. Ok to be vulnerable. You are open and other people will open too.
			
			Involve collaborators early, but not too early
					Initial Idea
					Prototype
					Involve Collaborators
						Usually people involve others too late
					Code, code, code
			
			Before involving colaborators
				Coherent design
					
				Mission Statement
					Goals and non-goals
					
				Some amount of running code. Proof of concept

		OK - Add MIT license to all files

		OK - README.md

	2021-06-27 =============
		OK - improve README.md
			add a simple example first
		
		OK - add README.md for test-recorder-demo

		OK - replace Assertions.assertEquals
		
	2021-06-28 =============
		OK - Create gmail and github account for TestRecorder
			gmail
				testrecorder2021@gmail.com / testrecorder_*
			github
				testrecorder / testrecorder_** email: testrecorder2021@gmail.com / 


		OK - Move repositories to testrecorder account and make them public

TODO ==========================

	Use gradle for build
		Read Gradle tutorial
		
		Convert Maven to gradle
		
		Publish 
		
		How to import in maven or in gradle?
			Update also README.md
	
		
	Add Java docs for all the public methos, except samples
	
	What will be the publish version? 
		0.2.0
	
	Start using github for issues
		use permalinks
		use labels, milestones
		
	
	
	If I am unable to create an object, I should still create it's dependencies and a commented code that sets it's private props
		ObjectInfoFactoryFallbackImpl
		ObjectInfoFactoryForNotRedFields

		What do I do when some fields could not be read? Do the same for all generic factories
			1. I could ignore them and consider just the rest of fields
			2. I could go to fallback
		I should keep depth of objects that could not be created. Avoid getting lost in internal unknown objects
		
	Read again exception handling best practices
		checking params 
		raising exceptions
		where to treat exceptions

	I should create objects as soon as possible
		this applies to mocked params and returns
			I should send first the params, then the return ... 
				write test to show the problem

		
	solve more TODOs or postpone to v2
	
	Demo to Rares, Claudiu+Sebi, 
	 
	Test in a real project
		See what problems appear
	
	Publish in github
		Publish a library to MAVEN Repository
			https://dzone.com/articles/how-to-create-a-java-library-from-scratch-to-maven
			https://central.sonatype.org/publish/requirements/
				Sign Files with GPG/PGP
				
		Read when the russian guy said about Git preparation

	Promote
		Add badges
			https://betterprogramming.pub/add-badges-to-a-github-repository-716d2988dc6a

		https://linux-audit.com/how-to-promote-your-open-source-project/

		DZone - article about spring-test-recorder

		Another use - reproduce a bug in an algorithm and isolate it in a use case
		
		https://github.com/zenika-open-source/promote-open-source-project/blob/master/README.md

		Add the link to the github in https://github.com/open-source-ideas/open-source-ideas/issues/281

v2 ==========================
    Use package org.springtestrecorder

	Should I differentiate between a mandatory TODO and a normal TODO?

	Configuration for TestRecorder. 
		Can i modify while running?
			https://stackoverflow.com/questions/52594764/how-to-hot-reload-properties-in-java-ee-and-spring-boot/52648630#52648630
		
		TestGeneration On/off. 
		
		testGenerator.getThreadId() == dependencyMethodRunInfo.getThreadId()

		for iterations, generate asserts/sideEffects for max 3 items and add a comment about the parameter
			in visibleProperties keep all

		For read objects I could limit the depth to 3-4 to avoid stack overflow. Later param + comment
		
		Enable/Disable logging
		
		Add the date in the name of the test function to be able to run them in order
			make it a parameter


	Try with gradle

	I can use protected properties/getters in assert if context.isObjectInSamePackageWithTest()


	Test what happens when you call a void returning method and want to mock it?
		Write test

	Exceptions thrown are not added to includes
		write test
			in mocks
			in test

	Handle more classes
		Class class 
		Calendar class
		All List<> from java.utils
		All Set<> from java.utils
		All HashMap<> from java.utils
		...
		
	Sometimes variable names are phased: list1, list4, list5
		I could assign names to objects only when adding them to the generated code

		
	Consider field default values for all the generic factories
		Do I need to do something? Think for each of them

	Maybe I should use both Annotations be for Class/Function?
		
	I should generate the code on disk. 
		If not possible, write to console
		Add a parameter to specify the path for generation


v3 ==========================
	Does it work in Spring projects without SpringBoot?

	Improve test coverage more? 
		It might involve writing tests for code that is 100% ok
		Like ToString that is used for debug.

	static fields are not handled yet

	How can I make it work in projects without spring?
		AspectJ should be called somehow

	For HashMap and HashSet we don't assert missing elements from side effects

	There is a problem with false getters. A getter should start with get or is and be followed be upper letter. There should be a corresponding field
	
	Sometimes we could get child objects separately before assert. Like Department department1 = result.getDepartment(). This works well in ObjectInfo
		
	I could have a fallback with serializable

	if you have a Component with multiple instances called from the RecordTest method, mocks will be duplicated

	full injection for ObjectInfoFactoryManager?
	
	Handle Generics

	arrays of arrays

	
v4 ==========================
	if needed object initialisation code could be learned from github	
	
	global variables changed - but this is not ok
	
	I could give significant var names from names of fields and getters
