
INFO ==========================
	There is another test recorder 
		http://testrecorder.amygdalum.net/index.html
		Get from github and try to see what tests are generated
		
	How to use proxy and dynamic-pointcut
		http://www.java2s.com/Code/Java/Spring/DynamicPointcutExample.htm
		http://stonefishy.github.io/blog/2015/06/12/spring-aop-dynamic-pointcut/
		Can I create proxy for the target service (if it's service) and use proxis for all the target dependencies?
		
		
		
	How to write custom annotations - in case I need
		What if the objects do not have public fields or getters?
		I need just a visitor inserted in all args and all dependencies of args
			will return objectState + name of params for all methods and constructors
		Easy solution - adnotate each class that I want to get the state with an Annotation
	
		We could do like Lombok does and inject some method to give us info about the dependencies
		http://notatube.blogspot.com/2010/12/project-lombok-creating-custom.html
		https://blog.frankel.ch/lombok-reduces-your-boilerplate-code/
		https://www.baeldung.com/java-annotation-processing-builder
		https://blog.frankel.ch/introductory-guide-annotation-processor/
			you can use a maven plugin to run such annotations
		Good Example of generating a class from annotations
			https://iammert.medium.com/annotation-processing-dont-repeat-yourself-generate-your-code-8425e60c6657
		Instrumentation example
			This is how mockito 2 can extend final classes
			https://www.developer.com/design/what-is-java-agent/
		See the sources of Lombok	
			https://github.com/projectlombok/lombok
		
		https://softwareengineering.stackexchange.com/questions/147055/when-is-unit-testing-inappropriate-or-unnecessary
		JUnit FAQ
			http://junit.sourceforge.net/doc/faq/faq.htm#best_1
		Types of functional tests
			https://www.simform.com/functional-testing-types/




DONE ==========================
	OK - Handle also exceptions thrown by act
		assertThrows(IllegalArgumentException.class, () -> new SampleService().testException(5));
	OK - if it's @Component or not

	OK - if the class has equals or not

	OK - handle arrays
	
	OK - handle ArrayList<>

	OK - the dependencies (also dependencies of dependencies ...)
		keep all dependencies in the test to avoid creation of 2 ObjectCodeGenerator for the same object
	OK - different objects can have common dependencies
		we need a dependency sorter
	OK - why args types are generated as 
			List<Person> arrayList1 and 
		but results as
			List result?
	OK - problem with repeated args

	OK - cache objects per TestGenerator

	OK - Get fields to set from getters and public fields to Optional<>
	
	OK Get constructors and their arguments
	
	OK - a object with an int == 0 will be initialized with NoArgs

	OK - see what happens when the fields are from superclass

	-----

	OK - Object creation for the target object

	OK - if there is a identifiable constructor covering all the fields
			Create with args constructor 

	OK - if there is a NoArg constructor + public fields
		Create with fields 
		
	-----
	
	OK - Refactor factory

	OK - // TODO create this object
		 // Person person = new Person();
		 // person.firstName = "firstName";
		 // person.lastName = "lastName"
		 // person.age = 35;
		 
	------
	
	OK - Create a function that will return the possible name of the setters
		Or that will find the setter Methods for a field name

	OK - if there is a NoArg constructor + all setters
		Create with setters 
		
	OK - Add objectState to context
	
	---------

	OK - The application being tested should not crash because of RecordTest

	OK - Problems with the CGLIB proxyes
		When a component is injected in a component a proxy is generated

	RecordMockForTest
		OK - create the type annotation and itercept all public calls inside the type
		
		OK - Intercept all calls inside methods with RecordMockForTest
			add them to RecordedMethodRunInfo.dependencyMethodRuns

	OK - check that both aspects run on the same thread

	OK - will match RecordedMethodRunInfo only with DependencyMethodRunInfo from the same thread
		store current thread
			int threadId = Thread.currentThread().getId()
			
	OK - RecordMockForTestAspect works only on injected components

	OK - implement first mocking

	OK - try with 2 mocked calls

	OK - try mock with 2 arguments

	OK - try when the mock argument is null
	
	OK - why is the import moving around between test runs?

	OK - handle exception thrown from the mocked function

	OK - exception thrown by mock for void returning functions

	OK - I should include doThrow

	OK - why NoSuchElementException cannot be created by the generic code?
		What should I do for such cases?
		We don't have to cover all cases for now. If an object cannot be created automatically, the user has to create it

	------
		OK - Enum
		OK - UUID
		OK - Fix getVariableName
		OK - Fix ObjectCodeGenerator constructor

	------
		OK - HashMap<>
	------
		OK - Set<>
		Solve !!!!
		
	------
		OK - escape strings
		OK - TODO rename the test to describe the use case
		OK - TODO refactor the generated code to make it easier to understand
		
		OK - Add generation date and tool
			but how can I ignore it in tests?
			Test Generated on ... with @RecordTest
		
	------

		
TODO ==========================
	OK - Write a demo to understand how the equality should behave
	
	Assert part
		call checkObjectValue("result");

		checkObjectValue(String path, Object object)
			OK - if exception was thrown
				no expectedResult init
				no check
		
			OK - object is void
				no expectedResult init
				no check
		
			OK - object is null
				no expectedResult init
				simple assertNull
				
			OK - primitive
				no expectedResult init
				simple assertEquals
				
			!!!! result == one of the known objects
				assertEquals(object, result)

			OK - object has equals
				expectedResult init if it's not in the Context already
				simple assertEquals
				
			object is known object (array / map / date / etc)
				check equality in a specific way
				
			object has getters / public fields
				for each field (ex: "firstName", "lastName", "department")
					checkObjectValue(path + "." + "firstName", object.firstName from map)
					checkObjectValue(path + "." + "getLastName()", object.lastName from map)
						


	Check side effects on target, arguments, any dependencies
		OK - Write a demo to understand the problem

		create assertEquals() for all the new values

		Bug. If I modify the params, the test will have them already modified
			I should get the values of params + target before the function is run
			I should get the values again after the function call to be able to assert
			
		
		TestGenerator should become TestContext
			every object should be tested before and after the call 

	===============================

	Rename project to TestRecorder

	Objects creation
		Calendar

	Could both Annotations be for Class/Function?
		
	I should generate the code on disk. 
		If not possible, write to console
		Add a parameter to specify the path for generation



	Is there a problem with boxed vs unboxed types?
		Ex: Float / float

	I should refactor the TestGenerator / TestGeneratorFactory
	Use @Getter(lazy=true) in TestGenerator/TestGeneratorFactory
		@Getter(lazy=true) private final double[] cached = expensive();


	Read again exception handling best practices
		checking params 
		raising exceptions
		where to treat exceptions
	
	Test what happens when you call a void returning method and want to mock it?


	Exceptions thrown are not added to includes
		in mocks
		in test
	
		
	I should add logging for debugging as a param of the Annotation
	
	Demo for IonutP, Rares ...
	 
	After the demo
		Package and publish locally
	
	Test in a real project
		See what problems appear

	Move all the test classes within the testrecording package
	
	Write tests for all the code that could break
		check coverage again

	JUnit FAQ
		Use @BeforeEach
		It's recommended to have one assert per test

	Sa citesc de la rus cum sa pregatesc cod pt Git

	
LATER ==========================
	Add the date in the in name of the test function to be able to run them in order
		make it a parameter


	I could have a fallback with serializable

	when expectedResult is one of the inited objects it's not reused

	if you have a Component with multiple instances called from the RecordTest method, mocks will be duplicated
	
	allow recording mocks from different threads

    What do I do when some fields cound not be read? Do the same for all generic factories
		1. I could ignore them and consider just the rest of fields
		2. I could go to fallback
		
	Consider field default values for all the generic factories
		Do I need to do something? Think for each of them

	Handle other Java common classes

	full injection for factories?
		for test have a util that creates the factory
	
	see what happens with the fields static

	test cyclic dependencies after I have other ways of object creation
		I tried with Lombok, but Lombok could not handle it

	Use JavaPoet to generate java code instead of my library

	if needed object initialisation code could be learned from github	
	
	Handle Generics

	there will be a case when the dependencies are circular

	create non-components with factory
	
	
	arrays of arrays
	
	global variables changed - but this is not ok
	
	static fields are not handled yet
	
	Daca mut calculul cazului si al dependin»õelor intr-un pas pregatitor, nu mai am ciclic dep.
	Pot sa fol object creation context
	
	Mai am undeva cyclic dep intre componente?
	
	
	
	

	
